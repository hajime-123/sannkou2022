

# drw作業5

## 別PCにdbeaverを利用してデータ移動

dbeaverのtaskを利用

![1](drw作業画像5/1.PNG)

dataexportを選択してname,descriptionを記述

![1](drw作業画像5/2.PNG)

CSVにするテーブルを選択。あとは標準設定でcsvが出力される

![1](drw作業画像5/3.PNG)

次にインポート

まずはdbを作りsql文でテーブルを作る。

![1](drw作業画像5/4.PNG)

作ったテーブルを選択しデータのエクスポートを選ぶ

![1](drw作業画像5/5.PNG)

先ほど出力したデータを選ぶ

![1](drw作業画像5/6.PNG)

無事にデータが入った

![1](drw作業画像5/6.PNG)



## tkinterでtoplevelのプログラムが停止していない。

draw3_graph.pyを起動

![1](drw作業画像5/8.PNG)

func_1にprint文を記載。

（１）naigaikeiを起動させた後サブ画面を閉じてみたがprint文が起動したままだった。

また下記のようにsub_winのインスタンスを確認してみたところ新たにウィンドウを作り直すたびに、新たなインスタンスが作られていることが判明した。

![1](drw作業画像5/9.PNG)

対策１

sub_win.destroyで消してみた

![1](drw作業画像5/10.PNG)

結果

バツ印で消すのと挙動が変わらなかった

対策２

`after` メソッドは戻り値として `id` を返却しますので、キャンセルしたい `after` メソッドの戻り値を `after_cancel` 実行時に引数として指定すれば良い

![1](drw作業画像5/11.PNG)

after部分に

![1](drw作業画像5/12.PNG)

ただこれでもうまくいかなかった。

対策3

after_cancelで別の書き方にしてみる。

![1](drw作業画像5/13.PNG)

after部分

![1](drw作業画像5/14.PNG)

これでも駄目だった。

対策4

対策１でOKだった。func_1を止めないといけないのでfunc_1にglobal sub_win_idを入れないといけなかった。

![1](drw作業画像5/15.PNG)

afterも止めて画面も消してみた。コマンド部分に複数関数を登録した。

![1](drw作業画像5/16.PNG)

ただよく考えたらstop_funcの中にsub_win.destroyを入れると一つの関数で複数処理してくれる

![1](drw作業画像5/17.PNG)

![1](drw作業画像5/18.PNG)

ボタンでafterを止め、ウィンドウを消すのではなく×で処理する。

![1](drw作業画像5/19.PNG)

成功した。使い勝手よくなるようにプログラムを修正していく。

例えばcommand=lambda:msg_show("ボタンが押されました。")のように引数を入れたりする。

![1](drw作業画像5/20.PNG)

![1](drw作業画像5/21.PNG)

各ウィンドウに対してafterの停止処理を入れることができた。



